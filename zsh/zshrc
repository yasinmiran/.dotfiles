#!/usr/bin/env zsh

# MIT License
#
# Copyright (c) 2021 Yasin Miran
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# ======================================================================================
# Exports
# ======================================================================================

# Some cool shell variables:
#
# $COLUMNS        Number of columns to use in Terminal view
# $DIRSTACK       List of directories used by the pushd and popd commands
# $GROUPS         Various groups with which the user is associated
# $HISTFILE       File containing the shell history
# $HOME           Home directory for the user
# $HOSTNAME       Name of the system on which the shell is running
# $LINES          Number of lines currently being used by the shell
# $PATH           List of directories the shell uses to resolve commands
# $PS1            String used as the primary prompt
# $PS2            String used as the secondary prompt
# $SHELL          Shell program being used
# $SHELLOPTS      Options in effect for the shell
# $TERM           Type of terminal that the shell is displaying its content to
# $UID            User ID of the currently logged-in user
# $USER           Username of the currently logged-in user
# $PWD            Present working directory
# _ (underscore)  Previously executed command
# $?              Previous command exit code 0...127

export DEVELOPMENT_DIR="$HOME/development"
export BINARIES_DIR="$HOME/binaries"
export DOTFILES_DIR="$HOME/.dotfiles"
export OMZ_INSTALLATION_PATH="$HOME/.oh-my-zsh"

# Fixes `insecure completion-dependent directories detected` error warning.
# https://github.com/ohmyzsh/ohmyzsh/issues/6835
# https://stackoverflow.com/a/61433333
export ZSH_DISABLE_COMPFIX="true"

export PATH="$PATH"

[ -d "/usr/libexec/java_home" ] && export JAVA_HOME="$(/usr/libexec/java_home -v1.8)"

# ======================================================================================
# Aliases
# ======================================================================================

alias ..="cd .."                    # go back one directory
alias ...="cd ../.."                # go back two directories
alias ....="cd ../../.."            # go back four directories
alias .....="cd ../../../.."        # go back five directories
alias ......="cd ../../../../.."    # go back six directories
alias ~="cd ~"                      # go to home but `cd` is probably faster to type.
alias -- -="cd -"                   # go to old directory == cd $OLDPWD

alias d="cd ~/Documents"            # go to documents
alias dl="cd ~/Downloads"           # go to downloads
alias dt="cd ~/Desktop"             # go to desktop
alias dev='cd $DEVELOPMENT_DIR'     # go to dev working directory
alias bins='cd $BINARIES_DIR'       # go to binaries directory
alias dotfiles='cd "$DOTFILES_DIR"' # Go to dotfiles directory

if exists "exa"; then
   alias ls="exa -laFh --git"  # Descriptive ls
fi
alias exa="exa -laFh --git" # Alias for default exa
alias cls="clear"           # Good old cls
alias rrr="exec zsh"        # Relaunch zsh

# Since we use oh-my-zsh there will lots of aliases loaded to the env. However,
# I want some commands the way I want so I'm overriding the similar existing
# ones with mine. First push all the above aliases and then pop back later.
PERSONAL_ALIASES=$(alias -L)

# ======================================================================================
# Functions
# ======================================================================================

# Abbreviated for: Go up by N number of directories.
#
# This function can go up *n number of directories upwards. If you are in a nested folder just executing
# `$ gupnod 10` will move you up 10 directories.
function gupnod() {

  # Reference of present working directory
  local c_dir && c_dir="$(pwd)"

  if [[ "${1}" == "" ]]; then
    c_dir="$(dirname "${c_dir}")"
  elif ! [[ "${1}" =~ ^[0-9]{1,2}$ ]]; then
    echo "Error: argument must be a number"
  elif ! [[ "${1}" -gt "0" ]]; then
    echo "Error: argument must be positive"
  else
    # Go through each dirname
    for ((i = 0; i < ${1}; i++)); do
      local n_cdir && n_cdir="$(dirname "${c_dir}")"
      if [[ "${c_dir}" == "${n_cdir}" ]]; then
        break
      else
        c_dir="${n_cdir}"
      fi
    done
  fi

  cd "${c_dir}" || exit

}

# Abbreviated: Organize my shit
#
# This function can organize the files based on their type. It is very much similar to macOS
# stacks however, it will create directories with the extension name instead of their category type.
#
# This function can operate without conflicting the existing folders.
# FIXME: this function is still WIP
function oms() {

  if [[ $PWD != "$HOME/Desktop" ]] || [[ $PWD != "$HOME/Downloads" ]]; then
    echo "That's a funny move ðŸ˜‚."
    return 0
  fi

  local cdir=$PWD

  for i in "$cdir"/*; do

    # if its a directory then we won't recurse instead,
    # we will put it into a dir called `stacks_dirs`.
    if is_directory "$i"; then
      mkdir -p "$cdir/stacks_dirs"
      echo "Moving $i to $cdir/stacks_dirs"
      continue
      # mv "$i" "$cdir/stacks_dirs/"
    fi

    if is_file "$i"; then
      ext=$(get_file_extension "$i")
      echo "File extension is $ext"
      if [[ -n "$ext" ]] && [ "$ext" != "." ]; then
        mkdir -p "$cdir/$ext"
        echo "Moving $i to $cdir/$ext/"
        # mv "$i" "$cdir/$ext/"
      else
        mkdir -p "$cdir/stacks_no_ext"
        echo "Moving $i to $cdir/stacks_no_ext/"
        # mv "$i" "$cdir/stacks_no_ext/"
      fi
    fi

  done

}

# Abbreviated for: Append to $PATH
# This function will append a path to $PATH and source the self itself.
function atop() {
  local new_path && new_path=${1}
  if [[ -n "$new_path" ]] && [[ -d "$new_path" ]]; then
    PATH="$PATH:$new_path"
  else
    echo "Nothing done. Path is invalid!"
  fi
}

# Abbreviated for: Make directory and Change directory.
# This function will create the given directory and cd into it immediately.
function mkcd() {
  echo "Creating directory $1 and navigating you into it." &&
    mkdir -p "$1" && cd "$1" || exit
}

# Find all matching aliases using alias-finder plugin.
function alf() {
  echo "Searching for aliases..." &&
    alias-finder -l "$1"
}

# This function is used to synchronize local dotfiles to
# this repository files.
function synchronize() {
  echo "Syncing to $DOTFILES_DIR" &&
    brew_dump
}

# ======================================================================================
# Default Command Executions
#
# Below this section is dedicated to source all the necessary environment and other
# source files for zsh. Note that some of the oh-my-zsh related ones are also sourced
# here to ensure consistency across files.
# ======================================================================================

readonly sources=(
  "$DOTFILES_DIR/zsh/oh_my_zsh"
  "$DOTFILES_DIR/git/defaults"
  "$DOTFILES_DIR/brew/defaults"
  "$DOTFILES_DIR/node/defaults"
  "$DOTFILES_DIR/docker/defaults"
  "$DOTFILES_DIR/workplace/wso2"
)

# Append binary paths to $PATH.
atop "/opt/homebrew/bin"
atop "/Applications/Visual Studio Code.app/Contents/Resources/app/bin" # VSCode shortcut

# New shell prompt message

echo -e "\nA new $(ps -o comm= $$) session created with pid $$ | zsh version: $ZSH_VERSION"
for sourze in "${sources[@]}"; do
  # shellcheck source=git/defaults
  . "$sourze"
done
eval "$PERSONAL_ALIASES"
echo -e "$USER's zsh environment is ready.\n"
